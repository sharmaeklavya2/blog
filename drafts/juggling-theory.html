<!DOCTYPE html>
<html lang="en">
<head>
<title>Eklavya's Blog - The role of math in juggling</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://sharmaeklavya2.github.io/blog/theme/base.css" />
<meta name="description" content="This post explains how math and computer science can be applied to juggling, a seemingly non-mathematical field. This gives us more insight into what really goes on in a juggling pattern and helps us automate the process of finding new juggling patterns. It is also used to give input to juggling animation software." />
<meta name="keywords" content="Juggling,Math" />
<link rel="stylesheet" href="https://sharmaeklavya2.github.io/blog/css/pygments-manni.css" />
<script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"extensions": ["AMSmath.js", "AMSsymbols.js", "noErrors.js", "noUndefined.js"]}, "extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/CommonHTML"]});</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
</head>

<body>
<nav>
<div class="primary">
<a id="sitetitle" href="https://sharmaeklavya2.github.io/blog/">Eklavya's Blog</a>
<label for="nav-checkbox" class="collapsor-lbl">&equiv;</label>
</div>
<div class="focus-capturer" tabindex="0">
<input id="nav-checkbox" class="collapsor" type="checkbox" />
<div class="collapsible">
<ul>
<li><a href="https://sharmaeklavya2.github.io">About me</a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/pages/about-this-blog.html">About this blog</a></li>
<li><ul class="tags">
<li>Feed:</li>
<li><a type="application/type+xml" rel="alternate" class="hori-flex" href="https://sharmaeklavya2.github.io/blog/feed/all.rss.xml">
<svg class="icon"><use xlink:href="https://sharmaeklavya2.github.io/blog/theme/sprites.svg#fa-rss-square"/></svg><span>RSS</span>
</a></li>
<li><a type="application/type+xml" rel="alternate" class="hori-flex" href="https://sharmaeklavya2.github.io/blog/feed/all.atom.xml">
<svg class="icon"><use xlink:href="https://sharmaeklavya2.github.io/blog/theme/sprites.svg#fa-rss-square"/></svg><span>Atom</span>
</a></li>
</ul></li>
</ul>
<p>Tags</p>
<ul>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/algorithms.html">Algorithms <span class="article-count">1</span></a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/math.html">Math <span class="article-count">1</span></a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/tutorial.html">Tutorial <span class="article-count">3</span></a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/web-dev.html">Web dev <span class="article-count">1</span></a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/juggling.html">Juggling <span class="article-count">3</span></a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/about-me.html">About me <span class="article-count">1</span></a></li>
</ul>
</div>
</div>
</nav>

<div id="main">
<article id="content" class="body">
<h1 class="entry-title">The role of math in juggling</h1>
<table class="post-details">
<tr><td>Published</td>
<td><time class="published" datetime="2020-08-30T00:00:00+05:30">
30 Aug 2020</time></td></tr>
<tr><td>Tags</td>
<td><ul class="tags">
<li><a href="https://sharmaeklavya2.github.io/blog/tag/juggling.html">Juggling</a></li>
<li><a href="https://sharmaeklavya2.github.io/blog/tag/math.html">Math</a></li>
</ul></td></tr>
</table>
<div class="entry-content">
<p>This post explains the surprising link between math and juggling.
Juggling theory is a beautiful example of how we can get more insight in
a seemingly non-mathematical area by building a theory and proving stuff.</p>
<p>Most of this post doesn't assume any specialized mathematical background.
Towards the end, basics of graph theory and number theory are used.</p>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#what-is-juggling">What is Juggling?</a></li>
<li><a href="#the-features-of-a-juggling-pattern">The features of a juggling pattern</a><ul>
<li><a href="#speed">Speed</a></li>
<li><a href="#dwell">Dwell</a></li>
<li><a href="#hand-position">Hand position</a></li>
<li><a href="#siteswap">Siteswap</a></li>
</ul>
</li>
<li><a href="#siteswap-examples">Siteswap examples</a></li>
<li><a href="#when-is-a-siteswap-valid">When is a siteswap valid?</a><ul>
<li><a href="#easy-part-of-the-proof">Easy part of the proof</a></li>
<li><a href="#not-so-easy-part-of-the-proof">Not-so-easy part of the proof</a></li>
</ul>
</li>
<li><a href="#other-things-about-siteswaps">Other things about siteswaps</a><ul>
<li><a href="#average-theorem">Average theorem</a></li>
<li><a href="#special-throw-orders">Special throw orders</a></li>
<li><a href="#extensions">Extensions</a></li>
<li><a href="#uses-and-limitations-of-mathematical-analysis">Uses and limitations of mathematical analysis</a></li>
</ul>
</li>
<li><a href="#want-to-learn-how-to-juggle">Want to learn how to juggle?</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<h2 id="what-is-juggling">What is Juggling?<a class="headerlink" href="#what-is-juggling" title="Permanent link">&para;</a></h2>
<p>Juggling is a recreational activity where a person manipulates multiple objects
(usually balls, rings or clubs) by repeatedly throwing and catching them.
If you haven't seen professional juggling before, I highly recommend watching this
<a href="https://youtu.be/wP8tbLBls_M?t=362" target="_blank">amazing performance by Anthony Gatto</a>.</p>
<p>There are different <em>patterns</em> in juggling.
The animations below depict three well-known patterns:
cascade, shower and fountain.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3.gif" />
    <figcaption>Cascade</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/51.gif" />
    <figcaption>Shower</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/4.gif" />
    <figcaption>Fountain</figcaption>
</figure>
</div>

<p>The fundamental problem in juggling theory is how to succinctly describe a juggling pattern.
I used GIF animations above to explain to you what cascade, shower and fountain mean,
but we are interested in a way of representing juggling patterns
that is much smaller (just a few characters long),
reveals the <em>structure</em> of the pattern, and can be read and analyzed by machines.
In 1981, Paul Klimek invented a way of associating a sequence of integers
to each juggling pattern. This sequence of integers is called a <em>siteswap</em>,
and it captures important properties of a jugging pattern.
In this post, I'll show how to succinctly represent juggling patterns,
and siteswaps form the most important part of this representation.</p>
<p>An amazing by-product of having such a representation is the ability to
automate the process of inventing new patterns
by brute-force enumeration of integer sequences.
Previously, only non-beginner jugglers could invent patterns using hit-and-trial.</p>
<p>Another advantage of siteswaps is that they can be used as input to
programs that create animations of juggling patterns.
In fact, this is exactly how I created all the animations in this post,
using <a href="https://jugglinglab.org/" target="_blank">Juggling Lab</a>.</p>
<h2 id="the-features-of-a-juggling-pattern">The features of a juggling pattern<a class="headerlink" href="#the-features-of-a-juggling-pattern" title="Permanent link">&para;</a></h2>
<p>There are some assumptions that we'll impose on juggling patterns.
These set of assumptions define our <em>model</em>.
Here we will look at a model that is powerful enough to capture most of the well-known patterns
and at the same time is simple enough to analyze.</p>
<p>Our first assumption is that we'll only look at patterns in the <em>steady state</em>,
i.e. we won't worry about how the juggler <em>started</em> juggling.
Alternatively, we can assume that the juggler started juggling at time <span class="math">\(t=-\infty\)</span>
and will continue to juggle till time <span class="math">\(t=\infty\)</span>.</p>
<p>A juggling pattern consists of several features that are orthogonal,
i.e. the features can be varied independently of each other.
We'll discuss some of the important features here, one of which is siteswap.
We'll start with features that are easy to understand,
and then move on to more complex but more important features.</p>
<h3 id="speed">Speed<a class="headerlink" href="#speed" title="Permanent link">&para;</a></h3>
<p>Every pattern can be made slower by throwing the objects higher.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3.gif" />
    <figcaption>Cascade</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/522.gif" />
    <figcaption>Slow cascade</figcaption>
</figure>
</div>

<p><strong>Assumption</strong>: <em>all throws are made at integral units of time.</em></p>
<p>A unit of time is called a <em>tick</em> or a <em>beat</em>.
The speed of a pattern is defined by the duration of a tick in seconds.</p>
<h3 id="dwell">Dwell<a class="headerlink" href="#dwell" title="Permanent link">&para;</a></h3>
<p>The amount of time the juggler holds an object in his/her hand is called <em>dwell</em>.
Dwell is measured in ticks.
Using a large dwell is called <em>lazy style</em>
and using a small dwell is called <em>hot-potato style</em>.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/522.gif" />
    <figcaption>Lazy cascade</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/900.gif" />
    <figcaption>Hot-potato cascade</figcaption>
</figure>
</div>

<p>For simplicity of presentation, assume that the dwell is the same for all throws/catches.</p>
<h3 id="hand-position">Hand position<a class="headerlink" href="#hand-position" title="Permanent link">&para;</a></h3>
<p>A pattern can be modified by changing the positions of hands during throws and catches.
Hand positions can be specified using a coordinate system.
(A standard practice is that the coordinate system for the right hand
is the mirror image of the coordinate system for the left hand.)</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3.gif" />
    <figcaption>Cascade</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-cross.gif" />
    <figcaption>Crossed-arm cascade</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-out.gif" />
    <figcaption>Reverse cascade</figcaption>
</figure>
</div>

<p>Reverse cascade is similar to the normal cascade,
except that instead of throwing from the inside and catching on the outside,
we throw from the outside and catch on the inside.
(A careful observation will reveal that the reverse cascade is actually a time-reversed
version of the normal cascade.)</p>
<p>By using more complicated hand-positions, we can get awesome variations
of the cascade, that don't really look like the cascade.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-mills.gif" />
    <figcaption>Mills mess</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-wind.gif" />
    <figcaption>Windmill</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-cherry.gif" />
    <figcaption>Cherry picker</figcaption>
</figure>
</div>

<p>As stated before, hand positioning is independent of other features of the pattern.
As an example, here are some hand positions applied to the fountain pattern:</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/4.gif" />
    <figcaption>Fountain</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/4-out.gif" />
    <figcaption>Reverse fountain</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/4-mills.gif" />
    <figcaption>Fountain mills mess</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/4-wind.gif" />
    <figcaption>Fountain windmill</figcaption>
</figure>
</div>

<h3 id="siteswap">Siteswap<a class="headerlink" href="#siteswap" title="Permanent link">&para;</a></h3>
<p>If you look at the first three animations (cascade, shower, fountain),
they have the same hand-positioning and can be made to have the same speed and dwell.
Yet these patterns look very different.
The feature that differentiates them is the order in which objects are thrown and caught.
This information is captured by siteswap.
This is where things start getting mathematical!</p>
<p><strong>Assumption</strong>: <em>hands throw alternately</em>, i.e. at even ticks, the left hand throws
and at odd ticks, the right hand throws. This assumption is called <em>asynchronicity</em>.</p>
<p><strong>Assumption</strong>: <em>a hand can only hold 1 object at a time.</em>
This restriction is called <em>non-multiplexing</em>.
(Most non-jugglers assume that non-multiplexing is mandatory for juggling,
but that's not always true.)</p>
<p>If all the other features (ticks per second, dwell, hand position) are fixed,
then a juggling pattern can be uniquely determined by specifying two things for each throw:
how high should the object be thrown, and whether the object is thrown to the same
hand or to the other hand.
(In the fountain pattern, all throws are made to the same hand,
and in cascade all throws are made to the other hand.)</p>
<p>To specify how high an object is thrown, we associate a number with the throw,
called <em>order</em> (also called <em>throw-order</em>).
The order of a throw is defined to be the flight-time of a throw in ticks, plus the dwell.
So if an object is thrown at time <span class="math">\(t\)</span> with order <span class="math">\(x\)</span>,
that object will be thrown next at time <span class="math">\(t+x\)</span>.
This implies that throw-orders must be integers.</p>
<p>Actually, we don't need to specify whether an object is thrown
to the same hand or not, because that can be inferred from the throw order.</p>
<p><strong>Lemma 1</strong>: An object is thrown to the same hand iff the throw-order is even.</p>
<p><em>Proof</em>. Define the parity of an integer <span class="math">\(y\)</span> to be 1 if <span class="math">\(y\)</span> is odd and 0 if <span class="math">\(y\)</span> is even.
Since hands throw alternately, the parity of the throwing time decides whether
the object is thrown from the left hand or the right hand.
Suppose an object is thrown at time <span class="math">\(t\)</span> with order <span class="math">\(x\)</span>.
Then it is thrown to the same hand iff the parities of <span class="math">\(t\)</span> and <span class="math">\(t+x\)</span> are the same,
which happens iff <span class="math">\(x\)</span> is even. <span class="math">\(\Box\)</span></p>
<p><strong>Assumption</strong>: <em>patterns are periodic.</em>
So, we only need to state the smallest repeating subsequence
of the infinite sequence of throw orders.
This finite-sized subsequence is called a siteswap.
The length of this subsequence is called the period of the siteswap.</p>
<p>Looking at a pattern and figuring out its siteswap
can be tricky at first, especially if you're new to juggling.
I'll show some examples so that you get the hang of it.</p>
<h2 id="siteswap-examples">Siteswap examples<a class="headerlink" href="#siteswap-examples" title="Permanent link">&para;</a></h2>
<p>Let's start with the simplest pattern: cascade.</p>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-analyze.gif" />
    <figcaption>Cascade</figcaption>
</figure>

<p>Firstly, note that all throws are identical.
So all throws have the same throw-order.</p>
<p>Suppose the blue ball is thrown at time <span class="math">\(t\)</span>.
At time <span class="math">\(t+1\)</span> the red ball is thrown, at time <span class="math">\(t+2\)</span> the green ball is thrown,
and at time <span class="math">\(t+3\)</span> the blue ball is thrown again.
Therefore, the time between consecutive throws of the blue ball is 3 ticks.
Hence, all throws have order 3.
This gives us the siteswap <code>[3]</code> for this pattern.</p>
<p>Let's now look at a pattern, which, as far as I know, doesn't have a common name.
It's identified solely by its siteswap.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/345.gif" />
    <figcaption>Normal</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/345-analyze.gif" />
    <figcaption>Slo-mo</figcaption>
</figure>
</div>

<p>We'll repeat the same trick as last time. Just keep noting down the colors of the throws.
Denote the colors gray, red, green, blue by characters <code>_</code>, <code>r</code>, <code>g</code>, <code>b</code>, respectively.
Then the colors of the throws is the string <code>_bg_rb_gr</code> repeated indefinitely.
Now for each throw, find the next throw of the same color,
and compute the difference of their throw-times to the get the throw-order.
This gives us the sequence <code>[3, 4, 5]</code> repeated indefinitely.</p>
<div class="codehilite"><pre><span></span><code>_bg_rb_gr_bg_rb_gr_bg_rb_gr
34534534534534534534534
</code></pre></div>


<p>Therefore, our siteswap is <code>[3, 4, 5]</code>.
Usually people just concatenate the numbers together and write <code>345</code> instead of <code>[3, 4, 5]</code>.
This is not a problem, since throw orders above 9 rarely arise in practice,
and even if they do, we can use <code>a</code> for 10, <code>b</code> for 11, and so on.</p>
<h2 id="when-is-a-siteswap-valid">When is a siteswap valid?<a class="headerlink" href="#when-is-a-siteswap-valid" title="Permanent link">&para;</a></h2>
<p>If we take an arbitrary sequence of integers, will it be the siteswap of some juggling pattern?
As we'll see, the answer turns out to be "no". But why?
Try to think about it before reading further.
(Hint: Is <code>43</code> a valid siteswap? If yes, what does it look like?
If no, why is it invalid?)</p>
<p>Turns out that to throw a ball, there must be a ball in your hand.
If your throw-orders at odd ticks are odd and throw-orders at even ticks are even,
balls will land in your hands only on even ticks,
so at odd ticks, eventually you won't have any balls left to throw.
But there's more. You also need to ensure that the number of balls
landing in your hand at each tick is not more than 1.
Otherwise, you'll have more balls than you can throw.
Think of these two constraints as the equivalent of <em>conservation of mass</em>.</p>
<p>So how can we find out if a sequence of integers is a valid siteswap?
I'll get straight to the point, like this:</p>
<p><strong>Permutation Theorem</strong>: Let <span class="math">\(a = [a_0, a_1, \ldots, a_{n-1}]\)</span> be a sequence of <span class="math">\(n\)</span> non-negative integers.
Let <span class="math">\(\mathbb{Z}_n = \{0, 1, \ldots, n-1\}\)</span>.
For each <span class="math">\(i \in \mathbb{Z}_n\)</span>, let <span class="math">\(b_i = (i + a_i) \bmod n\)</span>.
Then <span class="math">\(a\)</span> is a valid siteswap iff <span class="math">\(b\)</span> is a permutation of <span class="math">\(\mathbb{Z}_n\)</span>.</p>
<blockquote>
<p>Wait, <span class="math">\(a\)</span> is a sequence of <em>non-negative</em> integers? What does a throw-order of 0 mean?
<footer>observant reader</footer></p>
</blockquote>
<p>Good question! That's a technical detail that I conveniently brushed under the rug.
I'll address this at the end of the blog post.
For now, you can assume that <span class="math">\(a\)</span> only has positive integers
and throw orders can only be positive.
The proofs work for the general case that includes zero-order throws.</p>
<p>The permutation theorem gives us the following <span class="math">\(O(n)\)</span>-time algorithm (python code ahead):</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>  <span class="c1"># a list of n zeros</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>  <span class="c1"># i from 0 to n-1</span>
        <span class="n">b_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">n</span>
        <span class="n">freq</span><span class="p">[</span><span class="n">b_i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>


<p>We'll now try to prove the permutation theorem. To do that, we first need to get a good
characterization of what a valid siteswap is.
Essentially, we're trying to remove the <em>juggling</em> from the problem
and reduce it to a pure math problem.</p>
<p>Let <span class="math">\(a\)</span> be a sequence of <span class="math">\(n\)</span> non-negative integers.
We'll now define a function <span class="math">\(f_a: \mathbb{Z} \mapsto \mathbb{Z},\)</span>
that takes as input a <em>throw time</em> and outputs the corresponding <em>catch time</em>.
\[ f_a(x) = x + a[x \bmod n] \]
Here <span class="math">\(a[i] = a_i\)</span> and <span class="math">\(x \bmod n\)</span> is the remainder obtained after dividing <span class="math">\(x\)</span> by <span class="math">\(n\)</span>.</p>
<p>Now we need to prove two things:</p>
<ul>
<li>At any time <span class="math">\(y\)</span>, we have a ball to throw, i.e.
<span class="math">\(\forall y \in \mathbb{Z},\)</span> <span class="math">\(\exists x \in \mathbb{Z},\)</span> <span class="math">\(f_a(x) = y\)</span>.</li>
<li>We don't have collisions, i.e. there shouldn't be multiple balls landing
in your hand at the same time:
<span class="math">\(\forall x_1, x_2 \in \mathbb{Z},\)</span> <span class="math">\((f_a(x_1) = f_a(x_2)\)</span> <span class="math">\(\implies x_1 = x_2)\)</span>.</li>
</ul>
<p>Does this look familiar? This is exactly the definition of a bijection!
The first conditions says that <span class="math">\(f_a\)</span> should be onto,
and the second condition says that <span class="math">\(f_a\)</span> should be one-to-one.
Therefore, we get that <span class="math">\(a\)</span> is a valid siteswap iff <span class="math">\(f_a\)</span> is a bijection.</p>
<p>Define the predicate <span class="math">\(P\)</span> as:<br>
<em><span class="math">\(P(a)\)</span>: For <span class="math">\(b_i = (i + a[i]) \bmod n,\)</span> <span class="math">\(b\)</span> is a permutation of <span class="math">\(\mathbb{Z}_n\)</span>.</em><br>
Now the permutation theorem reduces to this lemma:</p>
<p><strong>Lemma 2</strong>: Let <span class="math">\(a\)</span> be a sequence of <span class="math">\(n\)</span> non-negative integers.
Then <span class="math">\(f_a\)</span> is a bijection iff <span class="math">\(P(a)\)</span>.</p>
<p>Lemma 2 has no reference to juggling. It's a purely mathematical fact.
Now that we're in familiar territory, you should try proving it yourself
before you read my proof below.</p>
<blockquote>
<p>Mathematics shares one feature with juggling:
for maximum enjoyment, you have to try it yourself.
<footer>Joe Buhler and Ron Graham<sup><a href="#cite-buhler-graham">[1]</a></sup></footer></p>
</blockquote>
<h3 id="easy-part-of-the-proof">Easy part of the proof<a class="headerlink" href="#easy-part-of-the-proof" title="Permanent link">&para;</a></h3>
<p><strong>Lemma 3</strong>: If <span class="math">\(f_a\)</span> is one-to-one, then <span class="math">\(P(a)\)</span> is true.</p>
<p><em>Proof</em>. Assume <span class="math">\(P(a)\)</span> is false. Then <span class="math">\(\exists i_1, i_2 \in \mathbb{Z}_n\)</span> such that
<span class="math">\(i_1 \neq i_2\)</span> and <span class="math">\(b[i_1] = b[i_2]\)</span>.</p>
<div class="math">\begin{align}
&amp; b[i_1] = b[i_2]
\\ &amp;\implies (i_1 + a[i_1]) \bmod n = (i_2 + a[i_2]) \bmod n
\\ &amp;\implies \exists k \in \mathbb{Z}, i_1 + a[i_1] = i_2 + a[i_2] + kn
\\ &amp;\implies \exists k \in \mathbb{Z}, f_a(i_1) = f_a(i_2 + kn)
\end{align}</div>
<p>
This is a contradiction, since <span class="math">\(f_a\)</span> is one-to-one.
Therefore, <span class="math">\(P(a)\)</span> is true. <span class="math">\(\Box\)</span></p>
<p><strong>Lemma 4</strong>: <span class="math">\(P(a)\)</span> implies that <span class="math">\(f_a\)</span> is one-to-one.</p>
<p><em>Proof</em>. Assume <span class="math">\(f_a\)</span> is not one-to-one.
Then <span class="math">\(\exists u_1 \neq u_2\)</span> such that <span class="math">\(f_a(u_1) = f_a(u_2)\)</span>.
Let <span class="math">\(i_1 = u_1 \bmod n\)</span> and <span class="math">\(i_2 = u_2 \bmod n\)</span>.</p>
<p><em>Case 1</em>: <span class="math">\(i_1 = i_2\)</span>.<br>
<span class="math">\(f_a(u_1) = f_a(u_2)\)</span> <span class="math">\(\implies u_1 + a[i_1] = u_2 + a[i_2]\)</span> <span class="math">\(\implies u_1 = u_2.\)</span>
This is a contradiction, since <span class="math">\(u_1 \neq u_2\)</span>.</p>
<p><em>Case 2</em>: <span class="math">\(i_1 \neq i_2\)</span>.
</p>
<div class="math">\begin{align}
&amp; f_a(u_1) = f_a(u_2)
\\ &amp;\implies u_1 + a[i_1] = u_2 + a[i_2]
\\ &amp;\implies i_1 + a[i_1] \equiv i_2 + a[i_2] \pmod{n}
\\ &amp;\implies b[i_1] = b[i_2]
\end{align}</div>
<p>
Since <span class="math">\(b\)</span> contains a duplicate entry, it cannot be a permutation of <span class="math">\(\mathbb{Z}_n\)</span>.
This contradicts <span class="math">\(P(a)\)</span>. Therefore, <span class="math">\(f_a\)</span> is one-to-one. <span class="math">\(\Box\)</span></p>
<h3 id="not-so-easy-part-of-the-proof">Not-so-easy part of the proof<a class="headerlink" href="#not-so-easy-part-of-the-proof" title="Permanent link">&para;</a></h3>
<p><strong>Lemma 5</strong>: If <span class="math">\(f_a\)</span> is one-to-one, then <span class="math">\(f_a\)</span> is onto.</p>
<p><em>Proof</em>.
There are 3 crucial insights in this proof.
The first is that we can represent <span class="math">\(f_a\)</span> as a graph of infinite size.
Formally, let <span class="math">\(G_a\)</span> be a graph whose vertex set is <span class="math">\(\mathbb{Z}\)</span>.
For each <span class="math">\(x \in \mathbb{Z}\)</span>, there is an edge from <span class="math">\(x\)</span> to <span class="math">\(f_a(x)\)</span>.
Hence, the out-degree of each vertex is 1.
<span class="math">\(f_a\)</span> is one-to-one means that the in-degree of each vertex is at most 1.
We want to show that <span class="math">\(f_a\)</span> is onto, i.e. every vertex has in-degree at least 1.
(Actually, there's a name for <span class="math">\(G_a\)</span> when <span class="math">\(a\)</span> is a valid siteswap:
it's called a <em>ladder diagram</em>.)</p>
<p>It is easy to see that if <span class="math">\((u, v)\)</span> is an edge in <span class="math">\(G_a\)</span>,
then for any <span class="math">\(k \in \mathbb{Z}\)</span>, <span class="math">\((u - kn, v - kn)\)</span> is also an edge in <span class="math">\(G_a\)</span>.
This is the second crucial idea of this proof.</p>
<p>The third crucial idea is to assign two labels to each number:
a major label <span class="math">\(M(x) = \lfloor x/n \rfloor\)</span> and a minor label <span class="math">\(m(x) = x \bmod n\)</span>.
We then partition <span class="math">\(\mathbb{Z}\)</span> by the major label.
Therefore, there are an infinite number of partitions and each partition has <span class="math">\(n\)</span> numbers.</p>
<p>For an arbitrary integer <span class="math">\(r\)</span>, consider the set <span class="math">\(S\)</span> of integers having major label <span class="math">\(r\)</span>.
There are <span class="math">\(n\)</span> edges that come out of <span class="math">\(S\)</span>, i.e. <span class="math">\(n\)</span> edges have their source vertex in <span class="math">\(S\)</span>.
We now ask: how many edges enter <span class="math">\(S\)</span>
(i.e. how many edges have their target vertex in <span class="math">\(S\)</span>)?
We'll now show that at least <span class="math">\(n\)</span> edges enter <span class="math">\(S\)</span>.
Since <span class="math">\(f_a\)</span> is one-to-one, this would prove that the number of edges entering <span class="math">\(S\)</span>
is equal to <span class="math">\(n\)</span> and each vertex in <span class="math">\(S\)</span> has in-degree exactly 1.</p>
<p>Let <span class="math">\(S = \{u_0, u_1, \ldots, u_{n-1}\},\)</span> where <span class="math">\(u_i = rn + i\)</span>.
Let <span class="math">\(v_i = f_a(u_i) = u_i + a[i]\)</span>.
Suppose the major label of <span class="math">\(v_i\)</span> is <span class="math">\(s\)</span>.
Then the major label of <span class="math">\(v_i - (s-r)n\)</span> is <span class="math">\(r\)</span>, so <span class="math">\(v_i \in S\)</span>.
Let <span class="math">\(w_i = u_i - (s-r)n\)</span>. Then the minor label of <span class="math">\(w_i\)</span> is <span class="math">\(i\)</span>.</p>
<p>Since <span class="math">\((u_i, v_i)\)</span> is an edge of <span class="math">\(G_a\)</span>, <span class="math">\((w_i, v_i - (s-r)n)\)</span> is also an edge in <span class="math">\(G_a\)</span>.
This edge enters <span class="math">\(S\)</span>. Also, the integers <span class="math">\(w_0, w_1, \ldots, w_{n-1}\)</span> are all distinct,
since <span class="math">\(w_i\)</span>'s minor label is <span class="math">\(i\)</span>.
Therefore, at least <span class="math">\(n\)</span> edges enter <span class="math">\(S\)</span>. <span class="math">\(\Box\)</span></p>
<h2 id="other-things-about-siteswaps">Other things about siteswaps<a class="headerlink" href="#other-things-about-siteswaps" title="Permanent link">&para;</a></h2>
<h3 id="average-theorem">Average theorem<a class="headerlink" href="#average-theorem" title="Permanent link">&para;</a></h3>
<p><strong>Average Theorem</strong>: Let <span class="math">\(a\)</span> be a siteswap of period <span class="math">\(n\)</span>.
Then the number of objects being juggled is <span class="math">\((\sum_{i=1}^n a_i)/n\)</span>.</p>
<p>The proof of the average theorem is quite involved, so I'm not going to put it here.
It uses the same ideas as in the proof of the permutation theorem.
It also gives a quick sanity check of a siteswap's validity:
the average should be an integer.</p>
<p>For the competitive programmers reading this who are looking for a challenge,
you may want to solve the problem
<a href="https://www.codechef.com/ICL2017/problems/ICL1703" target="_blank">ICL1703</a> on Codechef,
which is a generalization of the average theorem when multiplexing is allowed.
I have abstracted out juggling terminology from this problem,
so you don't need to know anything about juggling to understand it.
I have also written an
<a href="https://discuss.codechef.com/t/icl1703-editorial/14270" target="_blank">editorial</a> for it.</p>
<h3 id="special-throw-orders">Special throw orders<a class="headerlink" href="#special-throw-orders" title="Permanent link">&para;</a></h3>
<p>We assumed that we will throw a ball on every tick.
We can relax this assumption, without violating conservation of mass,
by allowing instances when no ball falls into your hand
and so you don't throw anything.
This situation is called a zero-order throw.
Here are some examples:</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/50505.gif" />
    <figcaption>Snake (50505)</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/330.gif" />
    <figcaption>Cascade with 1 ball <br>missing (330)</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/40.gif" />
    <figcaption>2-in-1 (40)</figcaption>
</figure>
</div>

<p>Sometimes you may want to keep holding on to a ball in your hand instead of throwing it.
This can be achieved via order-2 throws (think why it makes sense).</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/552.gif" />
    <figcaption>552</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/42.gif" />
    <figcaption>2-in-1 (42)</figcaption>
</figure>
</div>

<p>All the math in this blog post can be made to work with throws of order 0 and 2.</p>
<h3 id="extensions">Extensions<a class="headerlink" href="#extensions" title="Permanent link">&para;</a></h3>
<p>We assumed that in each tick, only one hand throws and hands throw alternately.
This assumption is called asynchronicity.
This is the most restrictive assumption that we have made.
There are several nice patterns that don't fit in this model.
Fortunately, all of the theory we saw here can be ported to the synchronous model,
and synchronous patterns have their own, somewhat different, siteswap notation.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/box.gif" />
    <figcaption>Box</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/columns.gif" />
    <figcaption>Columns</figcaption>
</figure>
</div>

<p>Further generalizations include multiplexing,
i.e. allowing multiple balls in a single hand, and passing,
i.e. multiple people juggling together.
Siteswap notation and the associated theory extends to these too.</p>
<div class="gallery">
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/multiplex-shower.gif" />
    <figcaption>Multiplexed shower</figcaption>
</figure>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/3-pass.gif" />
    <figcaption>Passing cascade</figcaption>
</figure>
</div>

<h3 id="uses-and-limitations-of-mathematical-analysis">Uses and limitations of mathematical analysis<a class="headerlink" href="#uses-and-limitations-of-mathematical-analysis" title="Permanent link">&para;</a></h3>
<p>We can invent new juggling patterns by brute-force enumeration of integer sequences
up to a certain length and then using the permutation theorem to filter out invalid sequences.
Each siteswap output by this process corresponds to a valid juggling pattern.
This is great, and rumors say that <code>441</code> was invented like this.</p>
<figure>
    <img src="https://sharmaeklavya2.github.io/blog/img/siteswaps/441.gif" />
    <figcaption>Half box (441)</figcaption>
</figure>

<p>However, this approach has limitations.
A lot of patterns look very similar to each other.
Out of the many patterns output by this algorithm,
only some may be aesthetically pleasing,
that too after carefully choosing an appropriate hand positioning.
So in practice, highly skilled humans outperform machines in inventing <em>interesting</em> patterns.</p>
<p>But that doesn't mean this theory is useless!
There are other uses of juggling theory,
like animation programs, transitioning across patterns,
generating patterns under constraints, etc.
Also, an understanding of juggling theory can help jugglers
invent interesting patterns more easily.
This is how I invented <code>615150</code> and <code>6051</code>,
and these patterns helped me learn to
<a href="https://sharmaeklavya2.github.io/blog/3-in-1.html">juggle 3 balls in 1 hand</a>.</p>
<p>You can try inventing your own patterns, and then easily see what they look like using
<a href="https://jugglinglab.org/" target="_blank">Juggling Lab</a>
or its <a href="https://jugglinglab.org/html/animinfo.html" target="_blank">GIF server</a>.</p>
<h2 id="want-to-learn-how-to-juggle">Want to learn how to juggle?<a class="headerlink" href="#want-to-learn-how-to-juggle" title="Permanent link">&para;</a></h2>
<p>Juggling is a very enjoyable hobby. If you feel motivated,
see my other blog post, <a href="https://sharmaeklavya2.github.io/blog/juggling-101.html">Juggling 101</a>, on how to learn juggling.</p>
<p>I started learning juggling a few months before I joined BITS Pilani as an undergraduate student.
By the end of my third semester, I had learned around 30 different patterns.
You can see my progress on
<a href="https://www.youtube.com/watch?v=xYrnQMHfDNE&list=PLACN_dyOcd_WSIzGV-4hVCQyQFmzKH1kb">
YouTube</a>.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<ol>
<li class="citation" id="cite-buhler-graham">
<!--<span class="cite-name">buhler-graham</span><br>-->
<span class="cite-authors">Joe Buhler and Ron Graham.</span>
<cite class="cite-title">
<a href="http://www.math.ucsd.edu/~fan/ron/papers/04_05_juggling.pdf" target="_blank">
Juggling patterns, passing, and posets.</a></cite><br>
<span class="cite-source">In Mathematical Adventures for Students and Amateurs (2004): 99&ndash;116.</span>
</li>
</ol>
</div>
</article>
</div>
</body>
</html>